import com.fasterxml.jackson.databind.ObjectMapper;
import org.json.JSONException;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.net.ssl.*;
import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.*;

public class VaultService {

    // ---------- ORIGINAL CONSTANTS (preserved) ----------
    private static final String VAULT_URL = "https://your-vault-server/v1/";   // set your vault base URL
    private static final String VAULT_NAMESPACE = "secret/data/";              // vault namespace/path prefix if applicable
    private static final String VAULT_NAME = "myapp/config";                   // the secret path name (under data)

    private static final String ENV = System.getenv("env") != null ? System.getenv("env") : "";
    private static final String ROLE_ID = "your-role-id";       // fill with actual role_id
    private static final String SECRET_ID = "your-secret-id";   // fill with actual secret_id

    // ---------- FIELDS (preserved / expanded) ----------
    private String vaultToken;                 // previous field, used by getAccessToken()
    private long expiresIn;                    // preserved
    private JSONObject pgData;                 // holds the vault secrets
    private HttpURLConnection conn;            // used by HTTP helpers

    private static Logger logger = LoggerFactory.getLogger(VaultService.class);

    // ---------- MAPPINGS ----------
    // Original had yamlMappings; added propertiesMappings as requested
    Map<String, String> yamlMappings = new HashMap<String, String>();
    Map<String, String> propertiesMappings = new HashMap<String, String>();

    // -------------------- MAIN --------------------
    public static void main(String[] args) {
        VaultService vault = new VaultService();

        // fetch secrets (from Vault)
        vault.getSecretsList();

        // init mappings (properties & yaml)
        vault.initiatePropertiesMapping();
        vault.initiateYamlMapping();

        // update both files
        vault.updatePropertiesFile();   // updates src/main/resources/application.properties
        vault.updateYamlFile();         // updates src/main/resources/application.yml

        System.out.println("âœ… application.properties and application.yml updated successfully");

        // ---------- original debugging / process builder logic preserved ----------
        String username = System.getProperty("user.name");
        System.out.println("user===" + username);

        String javaHome = "export JAVA_HOME=C:\\Homeware\\jdk-1.8.0_172-windows-x64";
        // example maven invocation (adjust args as needed)
        ProcessBuilder builder = new ProcessBuilder(
                "C:\\Users\\" + username + "\\bin\\apache-maven-current\\bin\\mvn.cmd",
                "clean", "install"
        );

        File file = new File(System.getProperty("user.dir"));
        builder.directory(file);
        System.out.println("Dir===" + builder.directory().getPath());

        try {
            builder.redirectErrorStream(true);
            Process process = builder.start();

            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                // print maven output lines
                System.out.println(line);
            }
            System.out.println(line); // note: will be null here (kept as in original snippet)

            int exitCode = process.waitFor();
            System.out.println("Process exited with code: " + exitCode);

        } catch (Exception e) {
            e.printStackTrace();
        }

        // revert yaml mapping (original method preserved), then update yaml again (as in original flow)
        vault.revertYamlMapping();
        vault.updateYamlFile();
    }

    // -------------------- GETTERS (preserved) --------------------
    public String getVaultUrl() {
        return VAULT_URL;
    }

    public String getVaultNamespace() {
        return VAULT_NAMESPACE;
    }

    public String getEnv() {
        return ENV;
    }

    // -------------------- FETCH SECRETS FROM VAULT --------------------
    /**
     * Calls Vault to fetch the configured secrets and stores result into pgData (as in original).
     */
    public JSONObject getSecretsList() {
        try {
            Map<String, String> headers = new HashMap<String, String>();
            headers.put("Content-Type", "application/json");
            headers.put("X-Vault-Token", getAccessToken());

            // Build GET request for the secret path
            HttpURLConnection request = buildGetRequest(new URL(VAULT_URL + VAULT_NAMESPACE + VAULT_NAME), headers);

            String response = getResponse(request);
            if (response == null || response.isEmpty()) {
                logger.error("VAULT ERROR: empty response from secrets endpoint");
                return null;
            }

            JSONObject jsonObject = new JSONObject(response);

            // Vault KV-v2: payload under data -> data
            // some Vault setups might be different; this matches your original snippet
            JSONObject data = new JSONObject(jsonObject.get("data").toString());
            pgData = new JSONObject(data.get("data").toString());

            // Print fields (preserved from your snippet)
            if (pgData.has("Pg_user"))
                System.out.println("pquser===>" + pgData.getString("Pg_user"));
            if (pgData.has("pg_pass"))
                System.out.println("pgpass===>" + pgData.getString("pg_pass"));
            if (pgData.has("client_id"))
                System.out.println("clientId===>" + pgData.getString("client_id"));
            if (pgData.has("client_secret"))
                System.out.println("clientSecret===>" + pgData.getString("client_secret"));

            return pgData;

        } catch (Exception e) {
            e.printStackTrace();
            logger.error("VAULT ERROR: Failed to retrieve secrets");
        }
        return null;
    }

    // -------------------- INIT MAPPINGS --------------------
    /**
     * mapping for application.properties (DB username & password)
     */
    private void initiatePropertiesMapping() {
        try {
            if (pgData == null) {
                logger.warn("pgData is null in initiatePropertiesMapping()");
                return;
            }
            // placeholders used in your properties file should match these keys
            propertiesMappings.put("datasource_username", pgData.getString("Pg_user"));
            propertiesMappings.put("datasource_password", pgData.getString("pg_pass"));
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }

    /**
     * mapping for application.yml (client id/secret etc.)
     */
    private void initiateYamlMapping() {
        try {
            if (pgData == null) {
                logger.warn("pgData is null in initiateYamlMapping()");
                return;
            }
            // placeholders used in your yml file should match these keys
            yamlMappings.put("client_id", pgData.getString("client_id"));
            yamlMappings.put("client_secret", pgData.getString("client_secret"));
            // add more mappings as needed, e.g. secret_id, api_key etc.
            if (pgData.has("secret_id"))
                yamlMappings.put("secret_id", pgData.getString("secret_id"));
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }

    // -------------------- UPDATE FILES --------------------
    /**
     * Update application.properties file with entries from propertiesMappings
     */
    private void updatePropertiesFile() {
        File file = new File("src/main/resources/application.properties");
        updateFileWithMappings(file, propertiesMappings);
    }

    /**
     * Update application.yml file with entries from yamlMappings
     */
    private void updateYamlFile() {
        File file = new File("src/main/resources/application.yml");
        updateFileWithMappings(file, yamlMappings);
    }

    /**
     * Shared helper to update any file by replacing placeholders with mapped values.
     * Preserves the original read -> replace -> write flow from your snippet.
     */
    private void updateFileWithMappings(File file, Map<String, String> mappings) {
        if (file == null) return;

        try {
            if (!file.exists()) {
                logger.warn("File not found: " + file.getPath());
                return;
            }

            List<String> newLines = new ArrayList<String>();
            List<String> lines = Files.readAllLines(file.toPath());

            for (String line : lines) {
                String newLine = line;
                for (String key : mappings.keySet()) {
                    if (line.contains(key)) {
                        // Use replace rather than replaceAll to avoid regex surprises
                        newLine = newLine.replace(key, mappings.get(key));
                    }
                }
                newLines.add(newLine);
            }

            // delete and recreate (as in your snippet)
            file.delete();
            Files.write(file.toPath(), newLines, StandardOpenOption.CREATE);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // -------------------- REVERT MAPPING (preserved) --------------------
    /**
     * revertYamlMapping was in your snippet; preserved behavior:
     * swaps back mapping (example logic based on original)
     */
    private void revertYamlMapping() {
        try {
            if (pgData == null) {
                logger.warn("pgData is null in revertYamlMapping()");
                return;
            }
            // original snippet did:
            // yamlMappings.put( pgData.getString("Pg_user"), "datasource_username");
            // replicating that behavior (i.e., swap key/value) so revert can replace values back to placeholders
            propertiesMappings.clear();
            propertiesMappings.put(pgData.getString("Pg_user"), "datasource_username");
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }

    // -------------------- VAULT AUTH (AppRole) --------------------
    private String getAccessToken() throws Exception {
        if (vaultToken == null || getExpirationTimeInSeconds() <= 60) {
            String response = getToken();
            if (response != null && !response.isEmpty()) {
                JSONObject jsonObject = new JSONObject(response);
                if (jsonObject.has("auth")) {
                    JSONObject clientToken = new JSONObject(jsonObject.get("auth").toString());
                    if (clientToken.has("client_token")) {
                        vaultToken = clientToken.getString("client_token");
                    }
                    if (clientToken.has("lease_duration")) {
                        try {
                            expiresIn = Long.parseLong(clientToken.get("lease_duration").toString());
                        } catch (Exception ignore) {}
                    }
                }
            }
        }
        return vaultToken;
    }

    private String getToken() {
        try {
            Map<String, String> vaultRequestBody = new HashMap<String, String>();
            vaultRequestBody.put("role_id", ROLE_ID);
            vaultRequestBody.put("secret_id", SECRET_ID);

            Map<String, String> headers = new HashMap<String, String>();
            headers.put("X-Vault-Namespace", VAULT_NAMESPACE);
            headers.put("content-type", "application/json");

            ObjectMapper objectMapper = new ObjectMapper();
            String requestBody = objectMapper.writeValueAsString(vaultRequestBody);

            HttpURLConnection request = buildRequest("POST", new URL(VAULT_URL + "auth/approle/login"), headers, requestBody);

            if (request != null) {
                int code = request.getResponseCode();
                if (code == 200 || code == 201) {
                    return getResponse(request);
                } else {
                    logger.error("Vault token request returned HTTP " + code);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            logger.error("VAULT ERROR: Vault Token Generation failed");
        }
        return "";
    }

    // -------------------- HTTP HELPERS (preserved trust manager code) --------------------
    private HttpURLConnection buildRequest(String requestMethod, URL url, Map<String, String> headers, String content) {
        try {
            TrustManager[] trustAllCerts = new TrustManager[] {
                    new X509TrustManager() {
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() { return null; }
                        @Override
                        public void checkClientTrusted(X509Certificate[] certs, String authType) throws CertificateException {}
                        @Override
                        public void checkServerTrusted(X509Certificate[] certs, String authType) throws CertificateException {}
                    }
            };

            SSLContext sc = SSLContext.getInstance("SSL");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

            // create all-trusting host name verifier
            HostnameVerifier validHosts = new HostnameVerifier() {
                @Override
                public boolean verify(String hostname, SSLSession session) { return true; }
            };
            HttpsURLConnection.setDefaultHostnameVerifier(validHosts);

            conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod(requestMethod);

            logger.info(requestMethod + " request to: " + url);

            if (headers != null) {
                for (String header : headers.keySet()) {
                    conn.setRequestProperty(header, headers.get(header));
                }
            }

            if (content != null) {
                conn.setDoOutput(true);
                OutputStream os = conn.getOutputStream();
                os.write(content.getBytes());
                os.flush();
                os.close();
            }

        } catch (NoSuchAlgorithmException | KeyManagementException e) {
            logger.info("SSL init error:: " + e.getMessage());
            e.printStackTrace();
        } catch (IOException e) {
            logger.info("IO error in buildRequest:: " + e.getMessage());
            e.printStackTrace();
        }
        return conn;
    }

    private HttpURLConnection buildGetRequest(URL url, Map<String, String> headers) throws IOException {
        return buildRequest("GET", url, headers, null);
    }

    private String getResponse(HttpURLConnection conn) throws IOException {
        int responseCode = conn.getResponseCode();
        logger.info("Response Code " + responseCode + " " + conn.getRequestMethod() + " " + conn.getURL());

        StringBuilder response = new StringBuilder();
        BufferedReader in = null;

        if (responseCode == HttpURLConnection.HTTP_OK || responseCode == 200 || responseCode == 201) {
            in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
        } else {
            // try reading error stream if present
            if (conn.getErrorStream() != null) {
                in = new BufferedReader(new InputStreamReader(conn.getErrorStream()));
            }
        }

        if (in != null) {
            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                response.append(inputLine);
            }
            in.close();
        }

        logger.info(response.toString());
        System.out.println(response.toString());
        return response.toString();
    }

    private long getExpirationTimeInSeconds() {
        if (expiresIn == 0) return -1;
        return expiresIn;
    }
}